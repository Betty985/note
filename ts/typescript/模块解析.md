模块解析就是指编译器所要依据的一个流程，用它来找出某个导入操作所引用的具体值。
- 首先，编译器会尝试定位表示导入模块的文件。 编译会遵循下列二种策略之一：Classic或Node。 这些策略会告诉编译器到哪里去查找moduleA。
- 如果它们失败了并且如果模块名是非相对的（且是在"moduleA"的情况下），编译器会尝试定位一个外部模块声明。
- 最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为error TS2307: Cannot find module 'moduleA'.
# 相对导入和非相对模块导入
相对导入是以`/`,`./`或`../`开头的。相对导入解析是相对于导入它的文件来的，并且不能解析为一个外部模块声明。 你应该为你**自己写的模块**使用相对导入，这样能确保它们在运行时的相对位置。
所有其它形式的导入被当作非相对的。 非相对模块的导入可以相对于baseUrl或路径映射来进行解析。 它们还可以**被解析成外部模块声明**。 使用非相对路径来导入你的**外部依赖。**
# 模块解析策略
共有两种可用的模块解析策略：Node和Classic。 你可以使用`--moduleResolution`标记指定使用哪种模块解析策略。 若未指定，那么在使用了`--module AMD | System | ES2015`时的默认值为Classic，其它情况时则为Node。
## Classic
这种策略以前是TypeScript默认的解析策略。 现在，它存在的理由主要是为了向后兼容。
- 相对导入的模块是相对于导入它的文件进行解析的。
对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。
## node
这个解析策略试图在运行时模仿Node.js模块解析机制。
在Node.js里导入是通过require函数调用进行的。 Node.js会根据require的是相对路径还是非相对路径做出不同的行为。
- 相对路径:视为文件；视为目录，检查是否它包含package.json文件并且其指定了一个"main"模块。将/root/src/moduleB视为目录，检查它是否包含index.js文件。 这个文件会被隐式地当作那个文件夹下的”main”模块。 
- 非相对路径。 Node会在一个特殊的文件夹node_modules里查找你的模块。 node_modules可能与当前文件在同一级目录下，或者在上层目录里。 Node会向上级目录遍历，查找每个node_modules直到它找到要加载的模块。
## TypeScript
TypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件。 因此，TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（.ts，.tsx和.d.ts）。 同时，TypeScript在package.json里使用字段"types"来表示类似"main"的意义 - 编译器会使用它来找到要使用的”main”定义文件。
先查找（.ts，.tsx和.d.ts），然后是合适的package.json（指定了"types"属性），之后是index文件。
非相对的导入会遵循Node.js的解析逻辑。
# 附加的模块解析标记
有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将.ts编译成.js，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。

TypeScript编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪些转换。

有一点要特别注意的是**编译器不会进行这些转换操作； 它只是利用这些信息来指导模块的导入。**
# Base URL
在利用AMD模块加载器的应用里使用baseUrl是常见做法，它要求在运行时模块都被放到了一个文件夹里。 这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。
设置baseUrl来告诉编译器到哪里去查找模块。 所有非相对模块导入都会被当做相对于baseUrl。

baseUrl的值由以下两者之一决定：

- 命令行中baseUrl的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）
- ‘tsconfig.json’里的baseUrl属性（如果给定的路径是相对的，那么将相对于‘tsconfig.json’路径进行计算）
注意**相对模块的导入不会被设置的baseUrl所影响，因为它们总是相对于导入它们的文件。**
# 路径映射
加载器使用映射配置来将模块名映射到运行时的文件。
TypeScript编译器通过使用tsconfig.json文件里的"paths"来支持这样的声明映射。
"paths"是相对于"baseUrl"进行解析。 如果"baseUrl"被设置成了除"."外的其它值，那么映射必须要做相应的改变。
通过"paths"我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另一个的位置。 构建过程会将它们集中至一处。 
# rootDirs指定虚拟目录
有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。

利用`rootDirs`，可以告诉编译器生成这个虚拟目录的roots； 因此编译器可以在“虚拟”目录下解析相对模块导入，就好像它们被合并在了一起一样。
使用"rootDirs"来告诉编译器。 "rootDirs"指定了一个roots列表，列表里的内容会在**运行时**被合并。
rootDirs的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑(bundles)和运行时的特性，比如条件引入和工程特定的加载器插件。
# 模块解析
编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过--traceResolution启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。
`tsc --traceResolution`
## 需要注意
- 导入的名字及位置
- 编译器使用的策略
- 从npm加载types
- 最终结果
## 使用--noResolve
正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件import，这个文件被会加到一个文件列表里，以供编译器稍后处理。--noResolve编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。
# 从编译列表中排除一个文件
tsconfig.json将文件夹转变一个“工程” 如果不指定任何“exclude”或“files”，文件夹里的所有文件包括tsconfig.json和所有的子目录都会在编译列表里。 如果你想利用“exclude”排除某些文件，甚至你想指定所有要编译的文件列表，请使用“files”。
有些是被tsconfig.json自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。

因此，**要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行import或使用了`/// <reference path="..." />`指令的文件。**