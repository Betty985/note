TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”
# 命名空间
命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。
它们可以在多文件中同时使用，并通过--outFile结合在一起。
因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 
`/// <reference path="Validation.ts" />`
命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的\<script/\>标签里。
但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。
# 模块
像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖。
模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。
是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。
对于Node.js应用来说，模块是默认并推荐的组织代码的方式。
从ECMAScript 2015开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。 因此，对于新项目来说推荐使用模块做为组织代码的方式。
# 注意
## 不能对模块使用`/// <reference>`
编译器是如何根据import路径（例如，import x from "...";或import x = require("...")里面的...，等等）来定位模块的类型信息的。
编译器首先尝试去查找相应路径下的.ts，.tsx再或者.d.ts。 如果这些文件都找不到，编译器会查找外部模块声明。
## 不必要的命名空间
TypeScript里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。 因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。
不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。 模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。

根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。 例如当目标模块系统为commonjs或umd时，无法使用outFile选项，但是在TypeScript 1.8以上的版本能够使用outFile当目标为amd或system。