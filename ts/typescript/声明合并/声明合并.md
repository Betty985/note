“声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。  合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并。
ts中的声明会创建的三种实体：
- 命名空间。创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。
- 类型。用声明的模型创建一个类型并绑定到给定的名字上
- 值。创建值的声明会创建在JavaScript输出中看到的值。
# 合并接口
机制：把双方的成员放到一个同名的接口里。接口的非函数的成员应该是唯一的。 如果它们不是唯一的，那么它们必须是相同的类型。 如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口A与后来的接口A合并时，后面的接口具有更高的优先级。

注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。

这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是单一的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。
# 合并命名空间
命名空间会创建出命名空间和值。

对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。

对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。

非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。

# 合并命名空间和类
- 可以表示内部类。
- 创建一个函数稍后扩展它增加一些属性也是很常见的。 TypeScript使用声明合并来达到这个目的并保证类型安全。
- 扩展枚举型。
# 注意
TypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 
# 模块扩展
模块名的解析和用import/export解析模块标识符的方式是一致的。 当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。
# 全局扩展

在模块内部添加声明到全局作用域中
```ts
export class Observable<T> {
    // ... still no implementation ...
}

declare global {
    interface Array<T> {
        toObservable(): Observable<T>;
    }
}

Array.prototype.toObservable = function () {
    // ...
}
```
全局扩展与模块扩展的行为和限制是相同的。