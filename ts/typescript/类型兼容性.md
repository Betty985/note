<!-- 跳过函数参数双向协变 -->

TypeScript里的类型兼容性是基于结构子类型的。
因为JavaScript里广泛地使用匿名对象
结构类型是一种只使用其成员来描述类型的方式。
TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。(给它它需要的)
这个比较过程是递归进行的，检查每个成员及子成员。
## 函数兼容
- 参数列表。要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 **允许忽略参数，因为忽略额外的参数在JavaScript里是很常见的。**
- 返回值类型。类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。
## 可选参数及剩余参数
比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。
当一个函数有剩余参数时，它被当做无限个可选参数。
## 函数重载
对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。
# 枚举
枚举类型与数字类型互相兼容。
```ts
enum Status { Ready, Waiting };
let hi:typeof Status.Ready=1
let ho:number= Status.Ready
```
不同枚举类型之间是不兼容的
# 类
比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。
## 私有成员
私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 
# 泛型
TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。
对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较
# 子类型与赋值
在TypeScript里，有两种类型的兼容性：子类型与赋值。 它们的不同点在于，赋值扩展了子类型兼容，允许给any赋值或从any取值和允许数字赋值给枚举类型或枚举类型赋值给数字。类型兼容性是由赋值兼容性来控制的。
# 补充
## 名义类型系统与结构类型系统
静态类型系统的职责之一是确定两种静态类型是否兼容：

- 实际参数的静态类型 U（例如，通过函数调用提供）
- 对应形式参数的静态类型 T（在函数定义中指定）

这通常意味着检查 U 是否为 T 的子类型。大致有两种检查方法：

- 在名义类型系统中，两个静态类型如果具有相同的标识（“名称”）则相等。如果明确声明了它们的子类型关系，则一种类型是另一种类型的子类型。
名义类型的语言为 C ++、Java、C#、Swift 和 Rust。
- 在结构类型系统中，两个静态类型具有相同的结构（如果它们具有相同的名称和相同的类型）则相等。如果 U 具有 T 的所有部分（可能还有其他），并且 U 的每个部分具有 T 的相应部分的子类型，则类型 U 是另一种类型 T 的子类型。
具有结构化类型的语言为 OCaml/ReasonML、Haskell 和 TypeScript。
## 协变和逆变
在一门程序设计语言的类型系统中，一个类型规则或者类型构造器是：

协变（covariant），如果它保持了子类型序关系≦。该序关系是：子类型≦基类型。
逆变（contravariant），如果它逆转了子类型序关系。
# 参考资料
- [ts中的类型](https://segmentfault.com/a/1190000021898024)
- [协变与逆变](https://zh.m.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98)