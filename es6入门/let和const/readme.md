# let
- let 用于声明变量，但是它是**块级作用域**，声明的变量只在let命令所在的代码块内有效。
-  **let不存在变量提升**，let声明的变量一定要在声明完后使用，否则报错。（let 存在变量提升，不会初始化。）
区块对let和const命令声明的变量，从一开始就形成了封闭作用域。在声明之前使用这些变量就会报错(**包括typeof 的方式**）。在语法上成为‘暂时性死区’。本质是进入当前作用域，变量就已经存在。但是等到声明变量的那一行代码出现，才可以获取和使用变量。
- **不允许在相同作用域内，重复声明同一个变量。** 不能在函数内部重新声明参数。
# const
- const声明一个只读的常量。const一旦声明变量就必须立即初始化。const保证变量指向的内存地址所保存的数据不得变动。建立变量名和内存地址的不可变冠旭。如果需要将对象冻结应该使用Object.freeze()方法。常规模式时修改会静默忽略，严格模式时修改会报错。对象的属性也冻结需要深冻结，递归冻结。
- 块级作用域
- 暂时性死区
- 不能重复声明
# 块级作用域
只有全局作用域和函数作用域，可能会导致内层变量覆盖外层变量，用来计数的循环变量泄漏为全局变量。    
- es6允许块级作用域的任意嵌套。内层作用域可以定义外层作用域的同名变量。     
- es6中允许在块级作用域中声明函数。在块级作用域中声明函数类似于let,在块级作用域之外不可引用。es5中函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。浏览器的es6环境中，块级作用域内声明的函数，行为类似于var声明的变量。其他环境的浏览器将块级作用域的函数声明当作let处理。**考虑到浏览器环境导致的差异太大，如果需要在块级作用域内声明函数应该写成函数表达式。**
- es6的块级作用域必须有大括号，如果没有大括号，js引擎认为不存在块级作用域。
