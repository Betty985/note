解构（Destructuring）：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。     
- 本质上属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。
- 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。不完全解构也可以成功。
- 解构赋值允许指定默认值。
     - ES6内部使用严格相等运算符判断一个位置是否有值。当数组成员严格等于undefined时，默认值才会生效。
     - 默认值是表达式时，表达式是惰性求值的，只有用到的时候才会求值。
     - 默认值可以引用解构赋值的其他变量，但是该变量必须已经声明(let 和 const的时候)。`var [x = y,y =1] = [];     //x=1; /y=1`
# 数组的解构赋值
只要数据结构具有Iterator接口，就可以采用数组形式的解构赋值。
等号右边不是可遍历结构（转为对象以后不具备Iterator接口）就会报错。（空对象本身不具有Iterator）
# 对象的解构赋值
- **数组的元素是按次序排列的，变量的取值由它的位置决定。而对象的属性没有次序，变量必须与属性同名。**
变量名和属性名不一致，必须写成 `let {a:b}={a:1}`。对象的解构赋值的内部机制，是先找到同名属性，如何再赋值给对应的变量。真正被赋值的是后者。
```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
// foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。
```
- 解构也可以用于嵌套解构的对象。如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。`// 报错 let {foo: {bar}} = {baz: 'baz'};`
- 对象的解构赋值可以取到继承的属性。
## 注意
- 将一个已经声明的变量用于解构赋值，要避免将大括号写在行首，避免js引擎将其理解为一个代码块从而发生语法错误。
```js
// 正确的写法
let x;
({x} = {x: 1});
```
- 解构赋值允许等号左边的模式之中，不放置任何变量名。
- 数组是特殊的对象，因此可以对数组进行对象属性的解构。
# 字符串的解构赋值
字符串也可以解构赋值。字符串被转换成一个类数组对象，还可以对它的length属性进行解构赋值。
```js
let arr = 'hello';
let {0 : first, [arr.length - 1] : last} = arr;
first // h
last // o
```
# 数组和布尔值的解构赋值
解构赋值规则，只要等号右边的值不是对象或数组就将其先转为对象。undefined和null无法转为对象，所以对它们解构赋值会报错。
# 函数参数的解构赋值
可以使用默认值，undefined会触发函数参数的默认值。
# 圆括号问题
**只有赋值语句的非模式部分，才能使用圆括号。**
不能使用圆括号的情况：
- 变量声明语句
- 函数参数（也属于变量声明）
- 赋值语句的模式
# 用途
- 交换变量的值
- 取出函数中返回的多个值（放在数组或对象里才能返回多个值）
- 函数参数的定义。将一组参数和变量名对应起来
- 提取json数据
- 函数参数的默认值
- 遍历Map结构
- 输入模块的指定方法。`let {SourceMapConsumer}=require('source-map')`