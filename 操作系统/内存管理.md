# 分层存储器体系

在现代计算机中，**存储器**是信息处理的来源与归宿，占据重要位置。但是，在现有技术条件下，任何一种存储设置，都无法同时从速度与容量两方面满足用户的需求。实际上它们组成了一个速度由快到慢，容量由小到大的存储装置层次。由操作系统协调这些存储器的使用。

# 内存管理的功能

- 主存的分配和管理：当用户需要内存时，系统为之分配相应的存储空间；不需要时及时回收以供其他用户使用。
- 提高主存储器的利用率：不仅能使多道程序动态地共享主存，提高主存利用率，最好还能共享主存中某个区域的信息。
- “扩充”主存容量：为用户提供比主存物理空间大得多的地址空间，以使用户感觉他的作业是在这样一个大的存储器中运行
- 存储保护：确保多道程序都在各自分配到存储区域内操作，互不感染，防止一道程序破坏其他作业或系统文件的信息。

# 地址空间与存储空间

地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。  
存储空间是主存中物理单元的集合。  
逻辑地址（相对地址，虚地址）：用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为 0，其余指令中的地址都相对于首地址编址。不能用逻辑地址在内存中读取信息。  
物理地址（绝地地址，实地址）：内存中存储单元的地址，可直接寻址。

# 内存共享

两个或多个进程共用内存中相同区域。  
目的：节省内存空间，提高内存利用率；实现进程通信（数据共享）  
共享内容：代码共享，数据共享

# 内存保护与安全

为多个程序共享内存提供保障，使在内存中的各道程序，只能访问它自己的区域，避免各道程序间相互干扰，特别是当一道程序发生错误时，不致于影响其他程序的运行。通常由硬件完成保护功能，由软件辅助实现。

- 保护系统程序区不被用户侵犯
- 不允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间）

保护过程：防止地址越界。每个进程都有自己独立的进程空间，如果一个进程在运行时所产生的地址在其地址空间之外,则发生地址越界。即当程序要访问某个内存单元时，由硬件检查是否允许，如果允许则执行，否则产生地址越界中断，由操作系统进行相应处理。

# 地址映射

处理器在执行指令时，必须把逻辑地址转换为物理地址后，才能存取信息。

- 程序地址就是物理地址：程序在编写或编译时进行地址映射。无地址空间概念。
  - 问题：两个程序都引用了绝对物理地址。
- 静态地址映射：程序在装载时进行地址映射。
  - 缺点：一个已开始执行的程序是无法在主存中移动的，如果该程序因某种原因暂时存放到辅存，若再调入主存时必须把它放回到主存的同一位置。
- 动态地址映射：程序在运行时进行地址映射。CPU 配置两个特殊硬件寄存器，基址寄存器和界限寄存器。程序装载到内存中连续的空闲位置且装载期间无需重定位，当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。

# 连续分配内存管理

连续分配为一个程序分配一个连续的内存空间。分为：

- 单一连续分配方式
- 分区分配/存储方式（可用于多道程序）

## 单一连续分配方式

在单道环境下，不管是单用户系统还是单道批处理系统，进程（作业）执行时除了系统占用一部分主存外，剩下的主存区域全部归它占用。  
主存划分为：系统区、用户区。系统区功操作系统使用，用户区供用户使用。用户区是一个连续的存储区所以又称单用户存储管理。  
特点：单用户系统在一段时间内，只有一个进程在内存，所以内存分配管理十分简单，但内存利用率低。

## 分区存储

将内存区域中划分为多个区，给每个作业分配一个区使用，并且每个作业只能在被分配的区中运行。

### 固定分区

在处理作业之前存储器就已经被划分为若干个分区，每个分区的大小可以相同，也可以不同。但是一旦划分好分区后，主存储器中的分区的个数就固定了，且每个分区的大小固定不变。

- 缺点：由于每个作业不一定恰好等于分区大小，所以会产生大量的内碎片，造成内存空间浪费。

### 可变分区

在作业加载时由操作系统根据作业实际大小来分配分区（作业大小等于分区大小）。这种方式能解决固定分区内存浪费的问题。  
有两种方法跟中内存使用情况：位图和空闲区链表。

#### 位图

内存中可能被划分成小到几个字达到几千字节的分配单元。每个分配单元对应位图中的一位，0 表示空闲，1 表示占用。

- 缺点：查找位图中指定长度的连续 0 串是耗时的，因为位图中该串可能跨越字的边界。

#### 空闲区链表

维护一个记录已分配内存段和空闲内存段的链表。其中链表中的一个结点或者包含一个进程或者是两个进程间的一块空闲区。

- 进程终止或换出时链表的更新非常直接。

#### 内存分配

分区的分配算法使用的数据结构是空闲区链表，按空闲区链表的方式不同，可以有以下四种算法：

- 最佳适应法：接到内存申请时，在空闲区链表中找到一个不小于请求的最小空块进行分配为作业选择分区时总是寻找其大小最接近于作业所要求的存储区域。要求将空闲区按大小顺序形成空闲区链表。
  - 特点：用最小空间满足要求，保留大的空闲区。
  - 是否最优？当次最优，但宏观上未必最优，因为每次分配后所分割下的剩余部分，总是最小的，很难再利用，从而形成碎块。
- 最坏适应法：接到内存申请时，在空闲区链表中找到一个不小于请求的最大空块进行分配，与最佳适应法相反，它在作业选择存储块时，总是寻找最大的空白区。
  - 特点：尽量利用存储空间，节约时间和开销，当分割后空闲块仍为较大空块，但是空间浪费比较大，碎片多。
- 首次适应法：要求空闲区链表以地址递增的次序链接。分配内存时，从链首开始顺序查找，直到找到满足其大小要求的空闲为止。
  - 特点:该算法倾向于优先利用内存低址区，从而保留高址部分的大空闲区，但会在低址区留下很多碎片，而每次查找又都是从低址区开始，无疑会增加查找空闲分区的开销。
- 下次适应法（循环首次适应法）：类似首次适应法每次分区时，总是从上次查找结束的地方开始，找到一个足够大的空白区分配。
  - 减少查找空闲分区开销，使内存中空闲分区分布更均匀，但会缺乏大的空闲分区。

# 内存回收

## 碎片问题与拼接技术

碎片问题：经过一段时间的分配回收后，内存中存在很多很小的空闲块。它们每一个都很小，这些空闲块被称为碎片。  
解决:拼接技术，通过内存移动程序将所有小的空闲区域合并为大的空闲区域。

- 拼接时机的选择：
  - 在某个分区回收时立即进行拼接
  - 当找不到足够大的空闲区，而空闲区的存储容量总和却可以满足作业需要时进行拼接。

# 内存超载

所有进程需要的内存数量总和通常要远远超出存储器能够支持的范围。  
用户在编制程序时，不应受内存容量限制，所以要采用一定技术来“扩充”内存容量，使用户得到比实际内存容量大得多的内存空间。  
具体实现：在硬件支持下，软硬件相互协作，将内存和外存结合起来统一使用。扩充内存使用户编制程序时不受内存限制。

## 处理内存超载的方法

### 交换技术

把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘，下次运行时再重新调入。

- 缺点：磁盘的存取速度慢，导致需要长时间才能换出一个大容量程序。
