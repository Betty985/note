原始值按值访问，引用值按引用访问。
- 动态属性：引用值可以随时添加，修改和删除其属性和方法。
- 复制值：原始值会被复制到新变量的位置，两个变量可以独立使用。引用值复制复制的是一个指向存储在内存中的对象的指针。
- 所有函数的参数都是按值传递的。函数外的值会被复制到函数内部的参数中。在按值传递参数是，值会被复制到一个局部变量（命名参数，或者说arguments对象中的一个槽位）
- ECMA-262 规定，任何实现内部`[[Call]]`方法的对象都应该在 typeof 检测时返回"function"。
- 变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象， 而这个上下文中定义的所有变量和函数都存在于这个对象上。上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。
- 作用域链增强，全局上下文和函数上下文两种(eval()调用内部存在第三种上下文)，但有其他方式来增强作用域链。某对 with 语句来说，会向作用域链前端添加指定的对象;对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。
# 垃圾回收
js是使用垃圾回收的语言，执行环境通过自动内存管理实现内存分配和闲置资源回收。

基本思路：确定哪个变量不会再使用，然后释放它占用的内存。
- 常用的垃圾回收策略是标记清理。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。
- 不太常用的垃圾回收策略是引用计数，思路时对每个值都记录它被引用的次数。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。存在循环引用的问题。
- 现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。
- 出于安全考虑，分配给浏览器的内存很少。为了避免运行大量 JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。
- 性能
  - 解除引用：如果数据不再必要，那么把它设置为 null，从而释放其引用。
  - 通过let和const提升性能：因为它们都是块作用域，可能会更早让垃圾回收程序介入。
  - 隐藏类和删除操作：运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类 的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。