# 笔记

## 组件基础

### 对 react 的理解

破题：**概念、用途、核心思路或运行流程、优缺点**

#### 概念

react 诞生于 jq、angular、backbone 相继流行的时代。jq 诞生于 2005 年，为了解决**浏览器兼容性**这个当时最大的问题，jq 封装 dom 操作，提供样式选择器，封装了 ajax、链式操作等大量基础函数。但是 jq**不能解决代码如何组织**的问题，甚至不能称之为框架，本质上只是一个工具函数集合。

随着 PC 性能越来越好，页面越来越复杂，**如何组织代码结构，有效提升复用率**成为了亟待解决的问题。2009 年，angular 带着 java 开发的先进经验来到前端世界，像 spring boot 一样提供了一揽子解决方案。angular 的分层设计齐全而优秀，覆盖了 web 开发的方方面面，如 MVC、数据绑定、前端路由、表单校验、设计模式等。jq 时代和 angular 时代的一个明显区别是 jq 时代的难点在于浏览器，而 angular 时代的难点在它本身。虽然代码组织清晰，双向绑定极大提升了中后台网站的开发效率，但 angular**无穷无尽的概念**让它看起来更像一个 java 框架。

2010 年，backbone 成为了一个很好的选择。

- 它的学习和改造成本低，大量的 jq 存量项目都可以尝试迁移，具有与前代的亲和性。

- 它考虑到了代码的组织性，引入了基础的 MVC 概念，提供集合与前端路由的封装，补齐了 jq 无序的短板。

前端项目在不断向工程化发展，但是仍有两个问题难以解决：

- 前端主要以 UI 组件为基础，需要一个可以使组件复用的开发方案，过去常见的复用方案是拼装模板。
- 组件作为基本单位应该是可以通过编写单元测试来维持稳定性的。过去通常从页面的维度思考，装上各种 jq 小插件。

在 react 中只要关心两件事：数据和组件。react 给定相同的输入状态会生成一致的组件。只有输入和输出是恒定的，它才是可测的。“组合优于继承”，在构建 UI 视图时，组合组件始终是最优的解决方案。react 通过组件化的方式解决视图层开发复用的问题。

#### 用途

react 的用途是**构建视图**。因为 react 采用了虚拟 dom，在适用场景上远比传统框架更为广泛。

- 支持 PC 和移动端网页；
- 可以用 react native 开发 iOS 和 Android 应用；
- react360 可以开发 VR 应用
- 可以开发命令行应用

**react 生态极大丰富了其使用场景**。

#### 核心思路

react 的核心思路是声明式、组件化与通用性（一次学习，随处编写）

##### 声明式

声明式编程的优点是直观，一目了然，也便于组合。

##### 组件化

组件化的优势在于视图的拆分与模块复用，更容易使系统的功能低耦合高内聚。react 组件化没有使用模板进行编写而是采用了声明式的 jsx。

##### 通用性

只要可以兼容虚拟 dom 就能直接运行 react。

#### 优缺点

优点：声明式、组件化和通用性

缺点：react 只是 js 库，路由和状态管理等功能，react 团队更希望交给社区解决。所以在技术选型和学习选择使用上有较高成本。

#### 总结

react 是用于构建用户界面的 JavaScript 库，通过组件化方式解决视图层开发复用的问题。核心设计思路有声明式、组件化和通用性。这也是 react 的优点，缺点是它需要向社区寻找并整合解决方案。

### 为什么 react 要使用 jsx？

破题：一句话解释、核心概念、方案对比

#### 解释

jsx 是一个 JavaScript 的语法扩展，类似于 XMl。

#### 核心概念

每个 JSX 元素只是调用 `React.createElement(component, props, ...children)` 的语法糖。在运行时会使用 babel 插件将 jsx 语法的代码还原为`React.createElement`的代码。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。但是使用 jsx 可以使代码变得更为简洁，层次更清晰，可读性强。

#### 方案对比

react 的设计初衷是关注点分离，希望通过合理的关注点保持组件开发的纯粹性。在 react 中关注点的基本单位是组件，单个组件是高内聚的，组件之间耦合度很低。

> 关注点分离在计算机科学中，是将代码分割为不同部分的设计原则，是面向对象的程序设计的核心概念。其中每一部分会有各自的关注焦点。
>
> 关注点分离的价值在于简化程序的开发和维护。当关注点分开时，各部分可以重复使用，以及独立开发和更新。具有特殊价值的是能够稍后改进或修改一段代码，而无须知道其他部分的细节必须对这些部分进行相应的更改。

其他技术方案分别是模板、模板字符串和 JXON。

##### 模板

**弱关注分离、引入概念多。**

react 认为引入模板是一种不佳的实现，因为非关注点的模板引入了更多了概念。

##### 模板字符串

**结构描述复杂，语法提示差。**

多次内部嵌套使代码结构复杂，开发工具的代码提示困难。

##### JXON

**语法提示差。**

大括号不能为元素在树中开始和结束，提供很好的代码提示。

#### babel 如何实现 JSX 到 JS 的编译？

实现原理：babel 读取代码并解析，生成 AST,把 AST 传入插件层进行转换。
babel 怎么实现从 jsx 到 js 的编译。

### 如何避免生命周期中的坑？

破题：梳理生命周期，明确周期函数指责。

#### 概念

周期：挂载阶段、更新阶段、卸载阶段

职责：状态变更、错误处理

> 挂载阶段：组件从初始化到完成加载的过程。

constructor

作用：

constructor 是类通用的构造函数，常用于初始化。过去 constructor 常用于初始化 state 和绑定函数。当类属性开始流行之后，react 社区的写法中去除了 constructor。

原因：

- constructor 中不推荐处理初始化以外的逻辑；
- constructor 本身只是 class 的初始化函数，不属于 react 的生命周期。
- 移除 constructor，代码会更简洁。

getDerivedStateFromProps

作用：getDerivedStateFromProps 的存在的唯一目的是让组件在 props 变化时返回一个对象来更新 state。

触发时机：

- props 被传入时；
- state 发生变化时；
- forceUpdate 被调用时；

只要父级组件重新渲染时，getDerivedStateFromProps 就会被调用。

反面模式：

- 直接复制 props 到 state，会导致 state 后没有正确渲染。
- props 变更后修改 state，父组件传来的 prop 值没有变化，不会重置。

UNSAFE_componentwillmount

作用：在组件加载之前做某些操作。但是在 react 的异步渲染机制下，该方法可能会被多次调用，目前已被标记为弃用。一个良好的设计应该是不让用户有较高的理解成本。

render

作用：render 返回的 jsx 结构用于描述具体的渲染内容。渲染时依靠 react 操作 jsx 描述结构来完成的。render 应该是一个纯函数，不应该产生副作用。

反面模式：

- 调用 setState：render 在渲染时调用，setState 会触发渲染，会造成死循环。
- 绑定事件：容易被频繁注册调用。

componentDidMount

作用：组件加载完成时做某些操作，如发起网络请求或绑定事件。在浏览器端可以认为 componentDidMount 在真实 Dom 绘制之后调用，在其他场景下，由于机器性能限制，视图可能还在绘制中。

> 更新阶段：外部 props 传入或者 state 发生变化的阶段

UNSAFE_componentWillReceiveProps

作用：功能可以被 getDerivedStateFromProps 替代，所以标记为弃用。getDerivedStateFromProps 存在时，UNSAFE_componentWillReceiveProps 不会被调用。

getDerivedStateFromProps

作用：getDerivedStateFromProps 的存在的唯一目的是让组件在 props 变化时返回一个对象来更新 state。

触发时机：

- props 被传入时；
- state 发生变化时；
- forceUpdate 被调用时；

只要父级组件重新渲染时，getDerivedStateFromProps 就会被调用。

反面模式：

- 直接复制 props 到 state，会导致 state 后没有正确渲染。
- props 变更后修改 state，父组件传来的 prop 值没有变化，不会重置。

shouldComponentUpdate

作用：通过返回 true 或 false 确定是否需要触发新的渲染。添加判断条件来阻止不必要的渲染。PureComponent 是更通用的优化方案，默认实现了 shouldComponentUpdate 函数，在函数中对 props 和 state 进行浅比较，判断是否触发更新。

UNSAFE_componentWillUpdate

在后续 react 的异步渲染设计中可能出现组件暂停渲染的情况，所以已废弃。

render

同挂载阶段一致。

getSnapshotBeforeUpdate

作用：配合 react 新的异步渲染机制，在 DOM 更新发生前被调用，返回值作为 componentDidUpdate 的第三个参数。

反面模式：不能使用 setState()

componentDidUpdate

作用：在更新后会被立即调用。首次渲染不会执行此方法。可以在这里对 DOM 进行操作或者发送网络请求。

反面模式：在 componentDidUpdate() 中直接调用 setState()，没有包裹在一个条件语句里，会导致死循环和额外的重新渲染。

> 卸载阶段：组件从 DOM 中移除

componentWillUnmount

作用：主要用于执行清理工作。

反面模式：没有接触事件绑定，取消定时器。

<hr/>

职责：

- 什么情况下触发重新渲染？
- 错误处理？

重新渲染：

- 函数组件：在任何情况下都会重新渲染，可以通过 React.memo 优化。React.memo 将跳过渲染组件的操作并直接复用最近一次渲染的结果。
- React.Component:如果不实现 shouldComponentUpdate，有两种情况触发重新渲染。state 发生变化；父组件的 props 传入；
- React.PureComponent:PureComponent 默认实现了 shouldComponentUpdate 函数，在 props 与 state 进行浅比较，确认有变更时才会触发重新渲染。

错误边界：

错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。

渲染时的报错，只能通过 componentDidCatch 捕获。

### react 的请求应该放在哪里？

异步请求应该放在 componentDidMount 中。从时间顺序看：

- constructor：可以放，但是 constructor 不承载业务逻辑，而且随着类属性的流行，constructor 已经很少使用了。
- componentWillMount:在新的异步渲染架构下会触发多次渲染，已标记为废弃。
- componentDidUpdate：如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。

### 类组件与函数组件有什么区别？

破题：共性与个性。

#### 相同点

组件是 react 最小代码片段，函数组件和类组件在使用方式和呈现效果上是完全一致的。

### 不同点

- 基础认知：类组件和函数组件代表了两种不同的设计思想和心智模式。类组件的根基是面向对象编程，有继承、属性和内部状态的管理；函数组件的根基是函数式编程，属于结构化编程的一种，假定输入和输出存在某种特定的映射关系。**函数组件更纯粹、简单、易于测试。这是他们最大的不同。**
- 独有能力：函数组件具有值捕获特性。函数组件里是快照值，而类组件里是最新值。类组件独有的是生命周期，可以通过生命周期包装业务逻辑。
- 使用场景：如果不使用 Recompose 或者 hooks，使用生命周期用类组件；在 Recompose 和 hooks 的加持下，类组件和函数组件的能力边界是完全相同的。
- 设计模式：类组件可以实现继承，而函数组件不行。但是 react 不推荐继承，组合优于继承。因为继承的灵活性差，屏蔽的细节太多。
- 性能优化：类组件的优化主要靠 shouldComponentUpdate 阻断渲染，函数组件的优化主要靠 React.memo 跳过渲染组件的操作并直接复用最近一次渲染的结果。
- 未来趋势：react 推荐使用函数组件，因为类组件存在三个问题：this 的模糊性（class 难以理解）、业务逻辑散落在生命周期中（复杂组件难以理解）、组件代码缺乏标准的拆分模式（状态复用难）

### 如何设计 React 组件？

破题：react 组件的设计模式。

#### 设计分类

react 社区通常将组件分为无状态组件或者有状态组件。
无状态组件（受控组件）可复用性、通用性更强，有状态组件（非受控组件）更关注业务。

> 在大多数情况下，你应该使用受控组件。

无状态组件的应用场景：

- 样式组件：样式判断逻辑分离到自身上，容易维护；
- 代理组件:封装属性，减少重复代码；切断外部组件库的强依赖性；可以批量修改基础组件的字段。
- 布局组件：是确定性，可以减少渲染。
  有状态组件的应用场景：
- 容器组件：拉取数据和组合组件
- 高阶组件：复用组件逻辑的高级技术。代码变得优雅，但是静态函数无法拿到(hoist-non-react-statics 可以自动复制所有静态函数)而且 ref 不能透传（可以用 forwardRef)
  - 逻辑复用：抽取公共逻辑，减少重复代码量
  - 链式调用
  - 渲染劫持：控制 render 函数修改输出内容，如加载效果

#### 工程实践

```js
src
├── components
│   ├── basic //最基本的展示组件
│   ├── container  //容器组件
│   └── hoc //高阶组件
└── pages //页面组件
```

### 如何在渲染劫持中为原本的渲染结果添加新的样式？

```js
function HOC(WrappedComponent) {
  return class Enhancer extends WrappedComponent {
    render() {
      const elementsTree = super.render();
      let newProps = {};
      if (elementsTree?.type === "input") {
        newProps = { value: "may the force be with you" };
      }
      const props = Object.assign({}, elementsTree.props, newProps);
      const newElementsTree = React.cloneElement(
        elementsTree,
        props,
        elementsTree.props.children
      );
      return newElementsTree;
    }
  };
}
```

render()返回的结构如下

```js
{
  type: "div";
  key: null;
  ref: null;
  props: Object;
  _owner: null;
  _store: Object;
}
```

## 状态管理

### setState 是同步更新还是异步更新？

破题：可能是 A；也可能是 B；甚至 A 和 B 同时存在的可能性也是有的。它的用途？

#### 作用

> setState() 会对一个组件的 state 对象安排一次更新。当 state 改变了，该组件就会重新渲染。

#### 同步和异步

> 目前，在事件处理函数内部的 setState 是异步的。例如，如果 Parent 和 Child 在同一个 click 事件中都调用了 setState ，这样就可以确保 Child 不会被重新渲染两次。取而代之的是，React 会将该 state “冲洗” 到浏览器事件结束的时候，再统一地进行更新。这种机制可以在大型应用中得到很好的性能提升。在以后的版本当中，React 会在更多的情况下静默地使用 state 的批更新机制。

#### 为什么异步更新？

> - 保持内部一致性：state,props,refs 是一致的，state 可以立即刷新，但是 props 不会；react 模型在内部是一致的，并且确保提升状态是安全的；
> - 启用并发更新：react 可以根据 setState 的调用来源分配不同优先级，进行异步渲染。
>   - 性能优化：减少重新渲染
>   - 用户体验优化：避免页面闪烁

### 如何面向组件跨层级通信？

破题：一个基本，多个场景。确定主题，再根据场景列举。

react 是一个组件化框架，基于组件树的位置分布，组件与组件之间的关系，大致可分为四种：

- 父子：props，比较常见，通常用于容器组件和展示组件
- 子父：子组件向父组件传递数据
  - 回调函数，通过回调函数的参数向父组件传递数据，如输入框组件
  - 实例函数，父组件通过 ref API 获取子组件的实例，然后调用子组件的实例函数，过去常见于 modal 框的显示与隐藏。
- 兄弟：依赖共同的父组件进行中转，主要负责在容器组件中协调各组件。
- 爷孙：
  - 将孙子组件的 props 封装在一个固定字段中。固定组件与跨组件有互相依赖的场景。
  - 通过 children 透传。嵌套不深的场景。
  - 通过 context API 传递。复杂嵌套透传场景。
- 无直接关系：没有直接的关联关系，但是需要共享、传递数据
  - react 的 context API，可以做语言包国际化。
  - 状态管理框架，如 mobx,redux,flux。引入状态管理使项目的开发模式与代码结构得以约束，但是学习成本相对较高。
  - 使用全局变量和事件，全局变量是通过在 Windows 上挂载新对象的方式实现，这种方式一般用于临时存储值，渲染显示时容易引发错误。全局事件就是使用 document 的自定义事件，如果存在时序依赖的两个事件加载时机存在差异，可能导致两者都没对应响应事件。

### react 状态管理框架

横跨多个层级之间的组件仍然需要**共享状态，响应变化**。context 存储的变量难以追溯数据源以及确认变动点。当组件依赖 Context 时，会提升组件耦合度，不利于组件的复用和测试。
流行的状态管理框架有 Flux、Redux、Mobx。

#### Flux

MVC 更适用于小型应用，但是在面向大型前端项目时，MVC 会使项目足够复杂，即每当添加新的功能，系统的复杂度就会疯狂增长。model 与 view 存在双向数据流动，很难理解和调试。所以 Facebook 抛弃了 MVC，提出了基于单向数据流的架构。store 存储了视图层的所有数据，当 store 变化后会引起 view 层更新。在视图层触发 action，action 会被 dispatcher 进行统一的收发处理，传递给 store 层。store 层已经注册过相关 action 的处理逻辑，处理内部状态变化后，会触发 view 层的更新。但因为它的概念和样板代码相对比较多，所以只在 facebook 内部大规模应用。

#### Redux

三大原则：单一数据源、纯函数 reducer、state 是只读的。

互动方式：actions->reducers->store->view

副作用：对主调用函数产生附加影响。redux 深受函数式编程的影响，所有的事件都由 action 触发，所有的状态都交给 store 去管理，业务逻辑交给 reducer 去处理。action,reducer 都是纯函数，store 只是一个 state 状态树，都不能处理副作用。

解决方案：

- 在 dispatch 的时候用中间件层拦截分发的 action 并添加额外的复杂行为。
- 允许 reducer 直接处理副作用。

#### Mobx

通过监听数据的属性变化，直接在数据上更改来触发 UI 的渲染。在 mobx 5 之前实现监听的方式是采用 Object.defineProperty,mobx 5 以后是 proxy。

## 渲染流程

### virtual DOM 的工作原理是什么？

破题：讲概念，说用途，理思路，核心问题

#### 概念

react 原型是 2010 年开源的 XHP,Facebook 创建 XHP 的主要目的是；

- 简化前端开发：后端赋能，让后端开发人员能够快速交付页面
- 避免跨站脚本攻击，也就是 XSS，XHP 的优势默认启用 XSS 保护。所有的页面在 XHP 中构建完成，html 都是通过转义的方式生成的。

但是如果是动态网页应用，一旦状态发生变更，网页就需要重新渲染，丢失网页的信息。对页面性能和用户体验都非常不利。
2011 年，Facebook 工程师 Jordan 完成了基于 js 的用户界面构建库——react 的开发工作。2012 年，Instagram 被 Facebook 收购，希望使用 react 技术栈，react 从 Facebook 内部技术栈剥离出来。
虚拟 DOM 的工作原理是通过 jS 对象模拟 DOM 节点。

#### 用途

虚拟 dom 的用途是提升代码抽象能力，避免人为 DOM 操作，降低代码风险，还可以应用于埋点统计和数据记录。
react 的 diff 函数用于计算状态变更前后的虚拟 DOM 树的差异；
渲染函数用于渲染整个虚拟 DOM 树或者处理差异点。react 的主要工作是组件实现和更新调度等计算工作。

#### 优势

- 性能优越：但是首次渲染或微量操作的场景下，虚拟 DOM 反而更慢。
- 规避 XSS：但是 react 的 dangerouslySetInnerHTML 可以绕过转义。
- 可跨平台：虚拟 DOM 的优势在于跨平台的成本更低。

#### 缺点

- 内存占用较高：虚拟 dom 是包含了真实 DOM 完整信息的对象，所以内存占用会上升
- 无法进行极致优化，对性能要求极高的应用，虚拟 DOM 无法进行针对性的极致优化

### react 的 diff 算法有什么不同？

破题：

- react： 讲概念，说用途，理思路，优缺点
- 类比框架：React-like（preact）、vue

#### diff 算法

diff 算法是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。
diff 算法的流程：

- 真实 DOM 与虚拟 DOM 存在一个映射关系，这个映射关系依靠初始化时的 JSX 建立完成；
- 虚拟 DOM 发生变化后，会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；
- 根据 patch 去更新真实的 DOM，反馈到用户的界面上。

更新时机：触发更新、进行差异对比的时机。更新发生在 setState、Hooks 调用等操作以后。

遍历算法：遍历算法是指沿着某条搜索路线，依次对树的每个节点做访问。通常分为两种：深度优先遍历和广度优先遍历。

- 深度优先遍历是从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点。
- 广度优先遍历是从根节点出发，在横向遍历二叉树层段节点的基础上，纵向遍历二叉树的层次。

react 的 diff 算法是深度优先遍历算法，因为广度优先遍历可能会导致组件的生命周期时序错乱，而深度优先遍历算法就可以解决这个问题。

优化策略：react 对 diff 算法做的优化手段。深度优先遍历保证了组件的生命周期时序不错乱，但传统的 diff 算法存在一个严重的性能瓶颈，复杂程度为 O(n^3)，其中 n 表示树的节点总数。react 通过分治的手段将复杂度降为 O(n)。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。

- 树比对：由于网页视图中较少有跨层级节点移动，两棵虚拟 DOM 树只对同一层次的节点进行比较。
- 组件比对：如果组件是同一类型，则进行树比对，如果不是，直接放入补丁之中。
- 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。

react16 起，引入了 fiber 架构，为了使整个更新过程可随时暂停恢复，节点与树分别采用了 fibernode 和 fibertree 进行重构。fibernode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两棵树双缓冲完成。workInProgress 更新完成后，再通过 current 相关指针指向新节点。

#### vue

vue2.0 因为使用了 snabbdom，所以整体思路与 react 相同。但在元素对比时，如果新旧两个元素是同一元素，且没有设置 key 时，snabbdom 在 diff 子元素中会一次性对比旧节点、新节点及它们的首尾元素四个节点，以及验证列表是否有变化。vue3 的 diff 整体变化不大。

#### 实践

- 根据 diff 算法的设计原则，应尽量避免跨层级节点移动。
- 通过设置唯一 key 进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。
- 设置 shouldComponentUpdate 或者 React.pureComponent 减少 diff 次数。

### react 的渲染流程？

react 的渲染过程大致一致，但协调并不相同，以 react 16 为分界线，分为 stack reconciler 和 fiber reconciler。协调从狭义上讲特指 react 的 diff 算法；广义上讲，也指 react 的 reconciler 模块，reconciler 模块包含了 diff 算法和一些公共逻辑。

stack reconciler 中核心调度方式是递归。调度的基本处理单位时事务，它的事务基类是 transaction。挂载主要通过 ReactMount 模块完成，更新通过 ReactUpdate 模块完成，模块之间相互分离，落脚执行点也是事务。

react 16 及以后，协调改成了 fiber reconciler。它的调度方式主要有两个主要特点：协作多任务模式，在这个模式下，线程会定时放弃自己的运行权利，交还给主线程，通过 requestIdleCallback；策略优先级，调度任务通过标记 tag 的方式分优先级执行。fiber reconciler 的基本单位是 fiber，fiber 基于过去的 react element 提供了二次封装，提供了指向父、子、兄弟节点的引用，为 diff 工作的双链表实现提供了基础。

在新的架构下，整个声明周期被划分为 render 和 commit 两个阶段。render 阶段的执行特点是可中断、可停止、无副作用，主要通过 workInProgress 树计算出 diff。以 current 树为基础，将每个 Fiber 作为一个基本单位，自下而上逐个节点检查并构造 workInProgress 树。
在 commit 阶段需要处理 effect 列表，这里的 effect 列表包含了根据 diff 更新 DOM 树，回调生命周期、响应 ref 等。commit 阶段是同步执行的，不可中断暂停，所以不要在 componentDidMount、componentDidUpdate、componentWiilUnmount 中去执行重度消耗算力的任务。

在动画、画布及手势等场景下，stack reconciler 会占用主线程，造成卡顿，而 fiber reconciler 的设计则能带来高性能的表现。

### react 的渲染异常会造成什么后果？

破题：“解释原理”（现象+原理）到“提供方案”（解决问题、预防问题、工程化方案）

#### 现象

> 过去，组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时 产生 可能无法追踪的 错误。这些错误基本上是由较早的其他代码（非 React 组件代码）错误引起的，但 React 并没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复。
> React 渲染异常的时候，在没有做任何拦截的情况下，会出现整个页面白屏的现象。它的成型原因是在渲染层出现了 JavaScript 的错误，导致整个应用崩溃。这种错误通常是在 render 中没有控制好空安全，使值取到了空值。

#### 提供方案

所以在治理上，从预防与兜底两个角度去处理。

在预防策略上：

- 渲染层数据转换错误：引入空安全相关的方案第一个是引入外部函数，比如 Facebook 的 idx 或者 Lodash.get；第二个是引入 Babel 插件，使用 ES 2020 的标准——可选链操作符；这个方案外部依赖少，侵入性小。
- 渲染层数据拼接错误：做内部培训，对易错点的代码进行指导，加强 Code Review。

在兜底策略上，为关键的 UI 组件添加兜底组件进行拦截,限制崩溃的层级。用这个高阶组件拦截报错信息，展示统一的错误页面.

量化：预防与治理方案覆盖率和线上报警数。

## 性能优化

### 如何分析和调优性能瓶颈？

破题：做优化是一个有指标、有比较、有数据的过程。
做工程应该有方案、有调研、有结果。
一个完整的解决方案应该是说清楚**标准**、讲清楚**原由**、理清楚**过程**、算清楚**结果**，用数据与收益来说明工作成果。

#### 理论基础

google 的 double click 小组做过一个研究，证明了网页性能在一定程度上影响用户留存率。研究显示，如果一个移动端页面加载时长超过 3s，用户就会放弃而离开。在此基础上 google 的 chrome 小组进一步提出了以用户为核心的 RAIL 模型，用更多的数字维度去诠释网页性能。
RAIL 模型是响应、动画、浏览器空闲时间、加载。

- 响应：应在 50ms 完成事件处理并反馈给用户；
- 动画：10 毫秒生成一帧；
- 浏览器空闲时间：最大限度利用浏览器空闲时间；
- 加载：在 5 秒内完成页面资源加载且使页面可交互。

#### 衡量工具

chrome 团队进一步提出了叫 light house 的测量工具。点击开发者工具就能找到它。点击 generate report，就可以直接生成一份网站性能报告。报告会对初次内容渲染、可交互时间、加载等具体的数值量化并打分，最后还会为整体性能给出一个分数。下面会有如何优化的指导意见。

#### 真实情况

light house 并不能真实反映出每个用户的设备的实际性能数据，而且它的分数反映的是业界标准，而不是项目需求的标准。所以需要自行完成性能指标的采集，可以使用网页 ARM 工具。这些工具都会对齐 light house 的业界标准。
常用的指标一般有：

- FCP：首次绘制内容的耗时。通常是记录初次加载并绘制内容的时间。
- TTI：是页面可交互时间。通常是记录 window.performance.timing 中的 domInteractive 与 fetchStart 的时间差；
- Page Load 页面完全加载时间：通常是记录 window.performance.timing 中的 loadEventStart 与 fetchStart 的时间差；
- FPS：前端页面帧率。通常是在主线程打点完成记录，其原理是 requestAnimationFrame 会在页面重绘前调用，而 FPS 就是计算两次之间的时间差。
- 静态资源及 API 请求成功率。通常是通过 window.performance.getEntries()。

#### 优化目标

在性能监控中有一个概念叫 TP，比如 TP50、TP90、TP99 和 TP999 等指标，指高于 50%、90%、99% 等百分线的情况。

场景：

- 对 2C 的页面来说：FCP、TTL、Page Load、FPS、静态资源及 API 请求成功率这几个指标很重要，会直接影响关键业务的转化率。而管理后台，更关注功能是否完整、运行是否流畅，对加载速度并没有很高的要求，通常只对 FPS、静态资源及 API 请求成功率更关注。指标的选择取决于业务形态。

实践：

- FCP：在页面上绘制一些内容给用户反馈。在 html 的 css 里写死一个 loading 图标，js 开始执行再移除掉；先用渲染骨架填充页面；SSR，也就是走服务端渲染。
- TTI：优先加载用户关注的内容。策略上主要是异步加载和懒加载结合。如：核心内容同步加载、非核心内容异步加载、内容中的图片懒加载。
- Page Load：异步加载，主要由 webpack 打包 common chunk 与异步组件完成。
- FPS：FPS 主要代表了卡顿的情况，在 react 中引起卡顿的主要原因有长列表和重渲染。长列表的通用解决方案是虚拟滚动，可以用 react-window 或者 react-virtualized。
- 静态资源及 API 请求成功率。对于静态资源，尽量使用 CDN，可以大幅提升静态资源的成功率。如果域名解析失败，可以采取静态域名自动切换或者 SRE 协助。
- 运营商对内容进行了篡改，可以用 https。

收益：
技术必须服务于业务。

### 如何避免重复渲染？

React 的性能问题通常有两类：长列表和重复渲染。
破题：优化时机，定位方式，常见的坑，处理方案

#### 优化时机

优化时机需要根据当前业务标准与页面性能数据分析来决定是否有必要。

#### 定位问题

- 复现问题，通常采用还原用户使用环境的方式进行复现，然后使用 performance 与 react profiler 工具进行分析，对照卡顿点与组件重复渲染次数及耗时排查性能问题。通常的解决方案是加 pureComponent 或者 React.memo 等组件缓存 API，减少重新渲染。但错误的使用方式会使其完全失效，比如在 jsx 的属性中使用箭头函数或者每次都生成新的对象。针对这样的情况有三个解决方案：
- 缓存，通常使用 reselect 缓存函数执行结果，来避免产生新的对象
- 不可变数据，使用数据 ImmutableJS 或者 immerjs 转换数据结构
- 手动控制，自己实现 shouldComponentUpdate 函数，容易带来 bug，可以作为保底手段。
### 如何提升React代码可维护性？
破题：软件工程角度
可维护性表示当前代码迭代的难易程度。ISO/IEC 9126的国际标准中指出产品可维护性反映了五个特征。
- 可分析性：工程项目拥有定位产品缺陷的能力（定位缺陷的成本）。
- 可改变性：指工程项目拥有基本的迭代能力（迭代成本）。
- 稳定性：避免工程项目因为代码修改而造成线上意外。
- 易测试性：工程项目能够快速发现产品缺陷的能力。
- 可维护性的依从性：遵循相关的标准或约定（团队开发工程规范）
#### 可分析性
可分析性的目标在于快速定位线上问题，可以从预防和兜底两个维度展开工作。预防主要依靠Lint工具与团队内部的code review。Lint工具重在执行代码规划，力图减少不合规的代码；而code review的重心在于增强团队内部的透明度，做好业务逻辑层的潜在风险排查。兜底主要是在流水线中加入sourcemap,能够通过线上报错快速定位源码。
#### 可改变性
可改变性的目标在于使代码易于拓展，业务易于迭代。工作主要从设计模式与架构设计展开。设计模式主要指组件设计模式，通过容器组件与展示组件划分模块边界，隔绝业务逻辑。整体架构设计采用rematch方案，rematch中可以设计的model概念可以很好地收敛action、reducer及副作用，同时支持动态引入model，保障业务横向拓展的能力。rematch的插件机制非常利于做性能优化。
#### 稳定性
稳定性的目标在于避免修改代码引起不必要的线上问题。主要通过提升核心业务代码的测试覆盖率来完成。因为业务发展速度快、UI变化大，所以基于UI的测试整体很不划算，但是背后沉淀的业务的逻辑得加测试。
#### 易测试性
易测试性的目标在于发现代码中的潜在问题。采用rematch的架构完成模块分离，整体业务逻辑挪到了model中，且model自身是一个纯对象，附加了多个纯函数。纯函数只要管理好输入与输出，在测试上就很容易。
#### 可维护的依从性
目标在于建立团队规范，遵循代码约定，提升代码可读性。主要是引入工具减少认为犯错的概率。主要有检查 JavaScript 的 ESLint，检查样式的 stylelint，检查提交内容的 commitlint，配置编辑器的 editorconfig，配置样式的 prettier。总体而言，工具的效果优于文档，团队内的项目整体可保持一致的风格，阅读代码时的切入成本相对较低。
## react hooks
### react hook 使用限制有哪些？
破题：列举限制、设计初衷、问题领域、方案原理、如何规避
#### 列举限制
- 只能在最顶层使用hook。不要在循环，条件或嵌套函数中调用hook。
- 只在react函数中调用hook。不要在普通的js函数中调用hook。
#### 设计初衷
为了改进react组件的开发模式。
#### 问题领域
在旧有的开发模式下遇到了三个问题；
- 在组件之间复用状态逻辑很难。过去常见的解决方案是高阶组件、render props及状态管理框架。
- 复杂组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。
- 难以理解的class。this问题（值捕获与类属性）和类难以优化问题。

所以hooks基于函数组件开始设计。
#### 方案原理
react知道哪个state对应哪个use State靠的是hook调用的顺序。hooks的设计基于数组，在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的hook。当然在react源码里的是链表。
#### 如何规避
可以引入eslint的hooks检查插件进行预防。
### useEffect与useLayoutEffect区别在哪里？
破题：共同点：使用方式、运用效果；不同点：使用场景、独有能力、设计原理、未来趋势
#### 共同点
- 使用方式：useLayoutEffect和useEffect函数签名相同，源码中最终都调用了mountEffectImpl的函数。两者使用方式完全一致，甚至一定程度上可以相互替换；
- 运用效果：两者都是处理副作用，React官方团队说不能掌握useLayoutEffect可以直接使用useEffect，遇到问题再尝试使用useLayoutEffect;
#### 不同点
- 使用场景：大多数场景下可以直接使用useEffect,但是如果代码引起了页面闪烁，可以使用useLayoutEffect。直接操作DOM样式或者引起DOM样式更新的场景更推荐使用useLayoutEffect。
- 设计原理：LayoutEffect和普通Effect的标记不一样，标记为HookLayout的effect会在DOM变更之后同步调用，所以可以使用它来读取DOM布局并同步触发重渲染。但是计算量大的耗时任务必然会造成阻塞。
- 未来趋势：会长期共存，暂时没有删减合并的计划。
### 谈谈React Hook的设计模式
破题：设计模式
#### 认知基础
“当我不再透过熟悉的class生命周期方法去窥视useEffect 这个Hook的时候，我才得以融会贯通。”同步和数据流，只需要关注外部依赖的变化。
#### 实践心得
- React.useMemo取代React.memo，因为React.memo并不能控制组件内部共享状态的变化；React.useMemo可以实现更精细化的控制。
- 函数组件每次渲染时都会重新执行，所以常量应该放到函数外部去，避免每次都重新创建。如果常量是一个函数并且需要使用组件内部的变量做计算，使用useCallback缓存函数。
- useEffect第二个参数在设计上是浅比较，如果传入的是引用类型，那么很容易会判定不想等，所以尽量不要使用引用类型作为判断条件。
#### 设计模式
采用外观模式，将业务逻辑封装到各自的自定义Hook中，组件内部只需调用单个自定义Hook暴露的接口。

> 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
## React 生态
### React-router的实现原理及工作方式分别是什么？
#### 实现原理
破题：基础原理和React Router内部的实践方案。
- 基础原理：切换Hash的方式可以依靠浏览器变化，如果是切换网址中的path，要用到HTML5 History API中的pushState、replaceState等。使用这个方式时，还需要在服务端完成historyApiFallback 配置。
- 实践方案：React Router内部主要依靠history库完成，这是由React Router 自己封装的库，为了实现跨平台的特性，内部提供了两套基础history，一套是直接使用浏览器的History API，用于支持react-router-dom;另一套是基于内存实现的版本，这是一个数组，用于支持react-router-native。
#### 工作方式
破题：整体设计模式与关键模块
- 整体设计模式：在架构上通过Monorepo进行库的管理。Monorepo具有团队间透明、迭代便利的优点。在数据通信上使用了Context API完成上下文传递。
- 局部关键模块：三类组件：
  - Context 容器：Router和MemoryRouter
  - 消费者组件：用以匹配路由，主要有Route、Redirect、Switch
  - 与平台关联的功能组件：Link、NavLink、DeepLinking等

### React中常用的工具库有哪些？
破题：分类、列举
分类法：二分法、矩阵法、公式法、过程法、要素法

过程：初始化、开发、构建、检查、发布

- 初始化：react官方推荐用create-react-app，生成项目时配置足够简单，但扩展及其麻烦。所以由第三方的react-app-rewired库对create-react-app提供扩展能力。国内还有umi和dva这样一站式解决方案。如果要初始化一个组件项目，create-react-library对组件的场景有优化，更适合发布组件。storybook支持大规模组件开发，交互式开发体验可以降低组件库的维护成本。
- 开发：
  - 路由：react-router
  - 样式：基础做法是CSS模块化，emotion通过提供props接口消灭内联样式。styled-component通过模版字符串提供基础的样式组件。
  - 基础组件：AntD
  - 功能组件：
    - react-dnd和react-draggable用于拖拽
    - react-pdf-viewer用于预览PDF
    - Video-react用于播放视频
    - react-window和react-virtualized用于解决长列表。
  - 状态管理：
    - flux
    - mobx
    - redux
- 构建：webpack用户多，实践验证完备，插件丰富。rollup专注于交付库，在交付场景下的打包更具备优势，支持多种模块类型输出。esbuild是打包及压缩工具，核心代码由Go编写，性能足够强。
- 检查：主要是代码规范和代码测试。代码规范检查一般是eslint，代码测试一般是jest
- 发布： s3-plugin-webpack主要是识别构建后的静态文件进行上传。